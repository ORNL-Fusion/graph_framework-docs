<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graph Framework: Adding New Operations Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Graph Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('new_operations_tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Adding New Operations Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#new_operations_tutorial_intro">Introduction</a></li>
<li class="level1"><a href="#new_operations_tutorial_node_subclass">Node Subclasses</a></li>
<li class="level1"><a href="#new_operations_tutorial_method">Methods overloads</a><ul><li class="level2"><a href="#new_operations_tutorial_evalute">Evaluate</a></li>
<li class="level2"><a href="#new_operations_tutorial_is_match">Is Match</a></li>
<li class="level2"><a href="#new_operations_tutorial_reduce">Reduce</a></li>
<li class="level2"><a href="#new_operations_tutorial_df">df</a></li>
<li class="level2"><a href="#new_operations_tutorial_compile_preamble">Compile preamble</a></li>
<li class="level2"><a href="#new_operations_tutorial_compile">Compile</a></li>
<li class="level2"><a href="#new_operations_tutorial_to_latex">To Latex</a></li>
<li class="level2"><a href="#new_operations_tutorial_is_power_like">Is Power Like</a></li>
<li class="level2"><a href="#new_operations_tutorial_get_power_base">Get power base</a></li>
<li class="level2"><a href="#new_operations_tutorial_get_power_exponent">Get power exponent</a></li>
<li class="level2"><a href="#new_operations_tutorial_remove_pseudo">Remove Pseudo</a></li>
<li class="level2"><a href="#new_operations_tutorial_to_vizgraph">To Vizgraph</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>A tutorial for creating new operations.</p>
<h1><a class="anchor" id="new_operations_tutorial_intro"></a>
Introduction</h1>
<p>In most cases, physics problems can be generated from combinations of graph nodes. For instance, the <a class="el" href="namespacegraph.html#a02c80d52ad57a00e98cb07d771caf993">graph::tan</a> nodes are built from \(\frac{\sin\left(x\right)}{\cos\left(x\right)}\). However, some problems will call for adding new operations. This page provides a basic example of how to impliment a new operator \(foo\left(x\right)\) in the graph_framework.</p>
<hr  />
 <h1><a class="anchor" id="new_operations_tutorial_node_subclass"></a>
Node Subclasses</h1>
<p>All graph nodes are subclasses of <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> or subclasses of other nodes. In the case of our \(foo\left(x\right)\) example we can sublass the <a class="el" href="classgraph_1_1straight__node.html">graph::straight_node</a> since these assume single arguments. If there are two or three operands you can subclass</p><ul>
<li><a class="el" href="classgraph_1_1branch__node.html">graph::branch_node</a></li>
<li><a class="el" href="classgraph_1_1triple__node.html">graph::triple_node</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Any existing node can be subclassed but do so with caution. Subclasses inherent reduction rules which maybe incorrect.</dd></dl>
<p>In this case, the <a class="el" href="classgraph_1_1straight__node.html">graph::straight_node</a> (Along with <a class="el" href="classgraph_1_1branch__node.html">graph::branch_node</a>, <a class="el" href="classgraph_1_1triple__node.html">graph::triple_node</a>) have no reduction assumputions. For this case since our operation \(foo\left(x\right)\) takes one argument, we will subclass the <a class="el" href="classgraph_1_1straight__node.html">graph::straight_node</a>.</p>
<p>The basics of subclassing a node, start with a subclass and a constructor. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T, <span class="keywordtype">bool</span> SAFE_MATH=false&gt;</div>
<div class="line"><span class="keyword">class </span>foo_node : <span class="keyword">public</span> straight_node {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> std::string to_string(leaf_node&lt;T, SAFE_MATH&gt; *x) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;foo(&quot;</span> +</div>
<div class="line">               <a class="code hl_function" href="namespacejit.html#a67f5624eaf42230fcddd7c6b5321900a">jit::format_to_string</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span> (l)) +</div>
<div class="line">               <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    foo_node(shared_leaf&lt;T, SAFE_MATH&gt; x) :</div>
<div class="line">    straight_node(x, foo_node::to_string(x.get())) {}</div>
<div class="line">};</div>
<div class="ttc" id="anamespacejit_html_a67f5624eaf42230fcddd7c6b5321900a"><div class="ttname"><a href="namespacejit.html#a67f5624eaf42230fcddd7c6b5321900a">jit::format_to_string</a></div><div class="ttdeci">std::string format_to_string(const T value)</div><div class="ttdoc">Convert a value to a string while avoiding locale.</div><div class="ttdef"><b>Definition</b> register.hpp:211</div></div>
</div><!-- fragment --><p> The static <code>to_string</code> method provices an idenifier that can be used to generate a hash for the node. This hash will be used later in a factory function to exsure nodes only exist once.</p>
<p>A factory function constructs a node then immedately reduces it. The reduced node is then checked if it already exists in the <a class="el" href="structgraph_1_1leaf__node_1_1caches__t.html#a8763928d01d20b97b3a6ec9ea347c0f0">graph::leaf_node::caches_t::nodes</a>. If the node is a new node, we add it to the cache and return it. Otherwise we discard the node and return the cached node in it's place. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T, <span class="keywordtype">bool</span> SAFE_MATH=false&gt;</div>
<div class="line">shared_leaf&lt;T, SAFE_MATH&gt; foo(shared_leaf&lt;T, SAFE_MATH&gt; x) {</div>
<div class="line">    <span class="keyword">auto</span> temp = std::make_shared&lt;foo_node&lt;T, SAFE_MATH&gt;&gt; (x)-&gt;reduce();</div>
<div class="line"><span class="comment">//  Test for hash collisions.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = temp-&gt;get_hash();</div>
<div class="line">         i &lt; std::numeric_limits&lt;size_t&gt;::max(); i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (leaf_node&lt;T, SAFE_MATH&gt;::caches.nodes.find(i) ==</div>
<div class="line">            leaf_node&lt;T, SAFE_MATH&gt;::caches.nodes.end()) {</div>
<div class="line">            leaf_node&lt;T, SAFE_MATH&gt;::caches.nodes[i] = temp;</div>
<div class="line">            <span class="keywordflow">return</span> temp;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (temp-&gt;is_match(leaf_node&lt;T, SAFE_MATH&gt;::caches.nodes[i])) {</div>
<div class="line">            <span class="keywordflow">return</span> leaf_node&lt;T, SAFE_MATH&gt;::caches.nodes[i];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To aid in introspection we also need a function to cast a generic <a class="el" href="namespacegraph.html#ac8853b055dcbbfd35dff9b4584d5ef36">graph::shared_leaf</a> back to the specific node type. For convience, we also define a type alias for shared type. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T, <span class="keywordtype">bool</span> SAFE_MATH=false&gt;</div>
<div class="line"><span class="keyword">using </span>shared_foo = std::shared_ptr&lt;add_node&lt;T, SAFE_MATH&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T, <span class="keywordtype">bool</span> SAFE_MATH=false&gt;</div>
<div class="line">shared_foo&lt;T, SAFE_MATH&gt; foo_cast(shared_leaf&lt;T, SAFE_MATH&gt; x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::dynamic_pointer_cast&lt;add_node&lt;T, SAFE_MATH&gt;&gt; (x);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="new_operations_tutorial_method"></a>
Methods overloads</h1>
<p>To subclass a <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> there are several methods that need to be provided.</p>
<hr  />
 <h2><a class="anchor" id="new_operations_tutorial_evalute"></a>
Evaluate</h2>
<p>To start, lets provide a way to <a class="el" href="classgraph_1_1leaf__node.html#a9dffad49122136d0353d709e0906e8b4">evalute the node</a>. The first step to evaluate a node is to evaluate the nodes argument. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; evaluate() {</div>
<div class="line">    <a class="code hl_class" href="classbackend_1_1buffer.html">backend::buffer&lt;T&gt;</a> result = this-&gt;arg-&gt;evaluate();</div>
<div class="line">}</div>
<div class="ttc" id="aclassbackend_1_1buffer_html"><div class="ttname"><a href="classbackend_1_1buffer.html">backend::buffer</a></div><div class="ttdoc">Class representing a generic buffer.</div><div class="ttdef"><b>Definition</b> backend.hpp:29</div></div>
</div><!-- fragment --><p> <a class="el" href="classbackend_1_1buffer.html">backend::buffer</a> are quick ways we can evalute the node on the host before needing to generate device kernels and is used by the <a class="el" href="classgraph_1_1leaf__node.html#adc40a5a5597f45f962cf297e3f4afec7">graph::leaf_node::reduce</a> method to precompute constant values. We can extend the <a class="el" href="classbackend_1_1buffer.html">backend::buffer</a> class with a new method to evaluate foo or you can use the existing operators. In this case lets assume \(foo\left(x\right)=x^{2}\). </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; evaluate() {</div>
<div class="line">    <a class="code hl_class" href="classbackend_1_1buffer.html">backend::buffer&lt;T&gt;</a> result = this-&gt;arg-&gt;evaluate();</div>
<div class="line">    <span class="keywordflow">return</span> result*result;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_is_match"></a>
Is Match</h2>
<p>This methiod checks if the node matches another node. The first thing to check is if the pointers match. Then we can check if the structure of the graphs match. This is important for the factory function. When checking for cached nodes, two graphs can be identical but have different pointer values. Checking the structure of the graphs ensures that we catch identical graphs. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_match(shared_leaf&lt;T, SAFE_MATH&gt; x) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == x.get()) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> x_cast = foo_cast(x);</div>
<div class="line">    <span class="keywordflow">if</span> (x_cast.get()) {</div>
<div class="line">        <span class="keywordflow">return</span> this-&gt;arg-&gt;is_match(x_cast-&gt;get_arg());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_reduce"></a>
Reduce</h2>
<p>Lets add a simple reduction method. When the argument \(x \) is a constant we can reduce this node down to a single constant by pre evaluating it. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; reduce() {</div>
<div class="line">    <span class="keywordflow">if</span> (constant_cast(this-&gt;arg).get()) {</div>
<div class="line">        <span class="keywordflow">return</span> constant&lt;T, SAFE_MATH&gt; (this-&gt;evaluate());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;shared_from_this();</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this example we first check if the argument can be cast to a constant. If it was castable, we evalute this node and create a new constant to return in its place. Otherwise we return the current node unchanged. </p><dl class="section note"><dt>Note</dt><dd>Other reductions are possible but not shown here.</dd></dl>
<hr  />
 <h2><a class="anchor" id="new_operations_tutorial_df"></a>
df</h2>
<p>Auto differentiation is provided by returning the derivative expression. \(\frac{\partial}{\partial y}foo\left(x\right)=2x\frac{\partial x}{\partial y}\). However, in this framework it is also possible to take a derivative with respect to itself \(\frac{\partial foo\left(x\right)}{\partial foo\left(x\right)}=1 \). </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; df(shared_leaf&lt;T, SAFE_MATH&gt; x) {</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;is_match(x)) {</div>
<div class="line">        <span class="keywordflow">return</span> one&lt;T, SAFE_MATH&gt; ();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> hash = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span> (x.get());</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;df_cache.find(hash) == this-&gt;df_cache.end()) {</div>
<div class="line">        this-&gt;df_cache[hash] = 2.0*this-&gt;arg*this-&gt;arg-&gt;df(x);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;df_cache[hash];</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here we made use of the <a class="el" href="classgraph_1_1leaf__node.html#aa5c836403ccaa4fe8231cbaaaac02060">graph::leaf_node::df_cache</a> to avoid needing to rebuild expressions everytime the same derivative is taken.</p>
<hr  />
 <h2><a class="anchor" id="new_operations_tutorial_compile_preamble"></a>
Compile preamble</h2>
<p>The <a class="el" href="classgraph_1_1leaf__node.html#afc102b9a3b9a61ec917750fe96e98f53">graph::leaf_node::compile_preamble</a> method provides ways to include header files or define functions. Lets use this method to define a function that can be called from the kernel. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> compile_preamble(std::ostringstream &amp;stream,</div>
<div class="line">                              <a class="code hl_typedef" href="namespacejit.html#a9822ffd072bb1abcde9176028aa24a5e">jit::register_map</a> &amp;registers,</div>
<div class="line">                              <a class="code hl_typedef" href="namespacejit.html#aed5672337b45a8b11f1351456d2284b8">jit::visiter_map</a> &amp;visited,</div>
<div class="line">                              <a class="code hl_typedef" href="namespacejit.html#a8f16308f3c321ac415daf451d0157a91">jit::register_usage</a> &amp;usage,</div>
<div class="line">                              <a class="code hl_typedef" href="namespacejit.html#a040839202e492715169f0e33e63c1e2a">jit::texture1d_list</a> &amp;textures1d,</div>
<div class="line">                              <a class="code hl_typedef" href="namespacejit.html#a7e7f6b3f955215cb43f9fde4d066ea2a">jit::texture2d_list</a> &amp;textures2d,</div>
<div class="line">                              <span class="keywordtype">int</span> &amp;avail_const_mem) {</div>
<div class="line">    <span class="keywordflow">if</span> (visited.find(<span class="keyword">this</span>) == visited.end()) {</div>
<div class="line">        this-&gt;arg-&gt;compile_preamble(stream, registers,</div>
<div class="line">                                    visited, usage,</div>
<div class="line">                                    textures1d, textures2d,</div>
<div class="line">                                    avail_const_mem);</div>
<div class="line"> </div>
<div class="line">        jit::add_type&lt;T&gt; (stream);</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot; foo(const &quot;</span></div>
<div class="line">        jit::add_type&lt;T&gt; (stream);</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot;x) {&quot;</span></div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;    return 2*x;&quot;</span></div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        visited.insert(<span class="keyword">this</span>);</div>
<div class="line"><span class="preprocessor">#ifdef SHOW_USE_COUNT</span></div>
<div class="line">        usage[<span class="keyword">this</span>] = 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        ++usage[<span class="keyword">this</span>];</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacejit_html_a040839202e492715169f0e33e63c1e2a"><div class="ttname"><a href="namespacejit.html#a040839202e492715169f0e33e63c1e2a">jit::texture1d_list</a></div><div class="ttdeci">std::map&lt; void *, size_t &gt; texture1d_list</div><div class="ttdoc">Type alias for indexing 1D textures.</div><div class="ttdef"><b>Definition</b> register.hpp:262</div></div>
<div class="ttc" id="anamespacejit_html_a7e7f6b3f955215cb43f9fde4d066ea2a"><div class="ttname"><a href="namespacejit.html#a7e7f6b3f955215cb43f9fde4d066ea2a">jit::texture2d_list</a></div><div class="ttdeci">std::map&lt; void *, std::array&lt; size_t, 2 &gt; &gt; texture2d_list</div><div class="ttdoc">Type alias for indexing 2D textures.</div><div class="ttdef"><b>Definition</b> register.hpp:264</div></div>
<div class="ttc" id="anamespacejit_html_a8f16308f3c321ac415daf451d0157a91"><div class="ttname"><a href="namespacejit.html#a8f16308f3c321ac415daf451d0157a91">jit::register_usage</a></div><div class="ttdeci">std::map&lt; void *, size_t &gt; register_usage</div><div class="ttdoc">Type alias for counting register usage.</div><div class="ttdef"><b>Definition</b> register.hpp:258</div></div>
<div class="ttc" id="anamespacejit_html_a9822ffd072bb1abcde9176028aa24a5e"><div class="ttname"><a href="namespacejit.html#a9822ffd072bb1abcde9176028aa24a5e">jit::register_map</a></div><div class="ttdeci">std::map&lt; void *, std::string &gt; register_map</div><div class="ttdoc">Type alias for mapping node pointers to register names.</div><div class="ttdef"><b>Definition</b> register.hpp:256</div></div>
<div class="ttc" id="anamespacejit_html_aed5672337b45a8b11f1351456d2284b8"><div class="ttname"><a href="namespacejit.html#aed5672337b45a8b11f1351456d2284b8">jit::visiter_map</a></div><div class="ttdeci">std::set&lt; void * &gt; visiter_map</div><div class="ttdoc">Type alias for listing visited nodes.</div><div class="ttdef"><b>Definition</b> register.hpp:260</div></div>
</div><!-- fragment --><p> The compile methods generate kernel source code. In this case we created a function in the preamble to evaluate foo. Since we only want this create this preamble once, we first check if this node has already been visited. The <a class="el" href="build_system.html#build_system_dev_options">build system option</a> <code>SHOW_USE_COUNT</code> tracks the number of times a node is used in the kernel. When this option is set we need to increment it's usage count. </p><dl class="section note"><dt>Note</dt><dd>Most nodes don't require a preamble so this method can be left out.</dd></dl>
<hr  />
 <h2><a class="anchor" id="new_operations_tutorial_compile"></a>
Compile</h2>
<p>The compile method writes a line of source code to the kernel. Here we can use the function defined in the preamble. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt;</div>
<div class="line"><a class="code hl_function" href="jit__test_8cpp.html#aba42e711f177787a48d91849e3ffcb09">compile</a>(std::ostringstream &amp;stream,</div>
<div class="line">        <a class="code hl_typedef" href="namespacejit.html#a9822ffd072bb1abcde9176028aa24a5e">jit::register_map</a> &amp;registers,</div>
<div class="line">        <a class="code hl_typedef" href="namespacejit.html#a9822ffd072bb1abcde9176028aa24a5e">jit::register_map</a> &amp;indices,</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_typedef" href="namespacejit.html#a8f16308f3c321ac415daf451d0157a91">jit::register_usage</a> &amp;usage) {</div>
<div class="line">    <span class="keywordflow">if</span> (registers.find(<span class="keyword">this</span>) == registers.end()) {</div>
<div class="line">        shared_leaf&lt;T, SAFE_MATH&gt; a = this-&gt;arg-&gt;compile(stream,</div>
<div class="line">                                                         registers,</div>
<div class="line">                                                         indices,</div>
<div class="line">                                                         usage);</div>
<div class="line"> </div>
<div class="line">        registers[<span class="keyword">this</span>] = <a class="code hl_function" href="namespacejit.html#aff060cfc1e5b5a499390c636dc80e147">jit::to_string</a>(<span class="charliteral">&#39;r&#39;</span>, <span class="keyword">this</span>);</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot;        const &quot;</span>;</div>
<div class="line">        jit::add_type&lt;T&gt; (stream);</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; registers[<span class="keyword">this</span>] &lt;&lt; <span class="stringliteral">&quot; = foo(&quot;</span></div>
<div class="line">               &lt;&lt; registers[a.get()] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">        this-&gt;endline(stream, usage);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;shared_from_this();</div>
<div class="line">}</div>
<div class="ttc" id="ajit__test_8cpp_html_aba42e711f177787a48d91849e3ffcb09"><div class="ttname"><a href="jit__test_8cpp.html#aba42e711f177787a48d91849e3ffcb09">compile</a></div><div class="ttdeci">void compile(graph::input_nodes&lt; T &gt; inputs, graph::output_nodes&lt; T &gt; outputs, graph::map_nodes&lt; T &gt; setters, const T expected, const T tolarance)</div><div class="ttdoc">Compile kernal and check the result of the output.</div><div class="ttdef"><b>Definition</b> jit_test.cpp:49</div></div>
<div class="ttc" id="anamespacejit_html_aff060cfc1e5b5a499390c636dc80e147"><div class="ttname"><a href="namespacejit.html#aff060cfc1e5b5a499390c636dc80e147">jit::to_string</a></div><div class="ttdeci">std::string to_string(const char prefix, const NODE *pointer)</div><div class="ttdoc">Convert a graph::leaf_node pointer to a string.</div><div class="ttdef"><b>Definition</b> register.hpp:245</div></div>
</div><!-- fragment --><p> Kernels are created by assuming infinite registers. In this case, a register is a temporary variable. To provide a unquie name, the node pointer value is converted into a string. Since we only want to evaluate this once, we check if the register has already been created.</p>
<hr  />
 <h2><a class="anchor" id="new_operations_tutorial_to_latex"></a>
To Latex</h2>
<p>This method returns the code to generate the \(\LaTeX \) expression for the node. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> to_latex ()<span class="keyword"> const </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;foo\left(;</span></div>
<div class="line"><span class="stringliteral">    this-&gt;arg-&gt;to_latex();</span></div>
<div class="line"><span class="stringliteral">    std::cout &lt;&lt; &quot;</span>\right)<span class="stringliteral">&quot;;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_is_power_like"></a>
Is Power Like</h2>
<p>This provides information for other nodes about how this works for reduction methods. In this care we need to set this to true. If this node did not act like a power, this method can be ignored. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_power_like()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_get_power_base"></a>
Get power base</h2>
<p>Return the base of the power node. This provides information for other nodes about how this works for reduction methods. In this case the power base is the function argument. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; get_power_base()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;arg;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_get_power_exponent"></a>
Get power exponent</h2>
<p>Return the exponent of the power node. This provides information for other nodes about how this works for reduction methods. In this case, the power exponent is \(2 \). </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; get_power_exponent()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> constant&lt;T, SAFE_MATH&gt; (<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span> (2.0));</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_remove_pseudo"></a>
Remove Pseudo</h2>
<p>Return the node with pseduo variables removed. <a class="el" href="classgraph_1_1pseudo__variable__node.html">graph::pseudo_variable_node</a> are used to end derivatives construction by treating a sub graph as a pseduo variable. Before graphs can be evaluated, these <a class="el" href="classgraph_1_1pseudo__variable__node.html">graph::pseudo_variable_node</a> need to be removed. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; remove_pseudo() {</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;has_pseudo()) {</div>
<div class="line">        <span class="keywordflow">return</span> sqrt(this-&gt;arg-&gt;remove_pseudo());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;shared_from_this();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="new_operations_tutorial_to_vizgraph"></a>
To Vizgraph</h2>
<p>Generates a <a href="https://graphviz.org">vizgraph</a> node for visualization. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> shared_leaf&lt;T, SAFE_MATH&gt; to_vizgraph(std::stringstream &amp;stream,</div>
<div class="line">                                              <a class="code hl_typedef" href="namespacejit.html#a9822ffd072bb1abcde9176028aa24a5e">jit::register_map</a> &amp;registers) {</div>
<div class="line">    <span class="keywordflow">if</span> (registers.find(<span class="keyword">this</span>) == registers.end()) {</div>
<div class="line">        <span class="keyword">const</span> std::string name = <a class="code hl_function" href="namespacejit.html#aff060cfc1e5b5a499390c636dc80e147">jit::to_string</a>(<span class="charliteral">&#39;r&#39;</span>, <span class="keyword">this</span>);</div>
<div class="line">        registers[<span class="keyword">this</span>] = name;</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; name</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot; [label = \&quot;foo\&quot;, shape = oval, style = filled, fillcolor = blue, fontcolor = white];&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> a = this-&gt;arg-&gt;to_vizgraph(stream, registers);</div>
<div class="line">        stream &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span> &lt;&lt; registers[a.get()] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;shared_from_this();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
