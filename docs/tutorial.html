<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graph Framework: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Graph Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial_introduction">Introduction</a></li>
<li class="level1"><a href="#tutorial_basic">Basic Nodes</a><ul><li class="level2"><a href="#tutorial_constant">Constant Nodes</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial_expression">Basic Expressions</a><ul><li class="level2"><a href="#tutorial_derivatives">Auto Differentiation</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial_workflow">Making workflows.</a><ul><li class="level2"><a href="#tutorial_workflow_iter">Iteration</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial_workflow_newton">Newton&#39;s Method.</a></li>
</ul>
</div>
<div class="textblock"><p>Hands on tutorial for building expressions and running workflows.</p>
<h1><a class="anchor" id="tutorial_introduction"></a>
Introduction</h1>
<p>In this tutorial we will put the basic <a class="el" href="general_concepts.html">General Concepts</a> of the graph_framework into action. This will discuss building trees, generating kernels, and executing workflows.</p>
<p>To accomplish this there is a playground tool in the <code>graph_playground</code> directory. This playground is a preconfigured executable target which can be used to test out the API's of this framework. The playground starts with a blank main function. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../graph_framework/jit.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * argv[]) {</div>
<div class="line">    <a class="code hl_define" href="graph__c__binding_8h.html#ad8adc1545da096be4d3c3323b41f6d85">START_GPU</a></div>
<div class="line">    (<span class="keywordtype">void</span>)argc;</div>
<div class="line">    (void)argv;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Insert code here. No code should be commited to this file beyond this</span></div>
<div class="line"><span class="comment">//  template.</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="graph__c__binding_8h.html#a9ed5f8a3efebcba6fb2b7eef9817d896">END_GPU</a></div>
<div class="line">}</div>
<div class="ttc" id="agraph__c__binding_8h_html_a9ed5f8a3efebcba6fb2b7eef9817d896"><div class="ttname"><a href="graph__c__binding_8h.html#a9ed5f8a3efebcba6fb2b7eef9817d896">END_GPU</a></div><div class="ttdeci">#define END_GPU</div><div class="ttdef"><b>Definition</b> graph_c_binding.h:133</div></div>
<div class="ttc" id="agraph__c__binding_8h_html_ad8adc1545da096be4d3c3323b41f6d85"><div class="ttname"><a href="graph__c__binding_8h.html#ad8adc1545da096be4d3c3323b41f6d85">START_GPU</a></div><div class="ttdeci">#define START_GPU</div><div class="ttdef"><b>Definition</b> graph_c_binding.h:132</div></div>
</div><!-- fragment --><p> To start, create a template function above main and call that function from main. This will allow us to play with different floating point types. For now we will start with a simple float type. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../graph_framework/jit.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * argv[]) {</div>
<div class="line">    <a class="code hl_define" href="graph__c__binding_8h.html#ad8adc1545da096be4d3c3323b41f6d85">START_GPU</a></div>
<div class="line">    (<span class="keywordtype">void</span>)argc;</div>
<div class="line">    (void)argv;</div>
<div class="line"> </div>
<div class="line">    run_tutorial&lt;float&gt; ();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="graph__c__binding_8h.html#a9ed5f8a3efebcba6fb2b7eef9817d896">END_GPU</a></div>
<div class="line">}</div>
</div><!-- fragment --><p> Here <a class="el" href="conceptjit_1_1float__scalar.html">jit::float_scalar</a> is a <a href="https://www.cppreference.com/w/cpp/20.html">C++20</a> <a href="https://www.cppreference.com/w/cpp/concepts.html">Concept</a> of valid floating point types allowed by the framework.</p>
<hr  />
 <h1><a class="anchor" id="tutorial_basic"></a>
Basic Nodes</h1>
<p>The graph_framework is built around applying the same equations to a large ensemble. Ensembles are defined from variables. All variables need to have same dimensionality. To create a variable we use one of the variable factory methods. For now we will build it without initalizing it. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::variable&lt;T&gt;</a> (1000, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacegraph_html_a2b36a8e136f4187b4de7e2e31a3e4168"><div class="ttname"><a href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::zero</a></div><div class="ttdeci">constexpr shared_leaf&lt; T, SAFE_MATH &gt; zero()</div><div class="ttdoc">Forward declare for zero.</div><div class="ttdef"><b>Definition</b> node.hpp:994</div></div>
</div><!-- fragment --><p> Here we are creating a <a class="el" href="classgraph_1_1variable__node.html">graph::variable_node</a> with the symbol \(x\) which holds 1000 elements. The symbol is used by the \(\LaTeX\) renderer as a symbol place holder. Any graph can be rendered to \(\LaTeX\) by calling the <a class="el" href="classgraph_1_1leaf__node.html#a352c9f2f999474709decec8acd8f79d0">graph::leaf_node::to_latex</a> method. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::variable&lt;T&gt;</a> (1000, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">    x-&gt;to_latex();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> When compiling and running the code, this will print out the \(\LaTeX\) code needed to generate the equation. By copy and pasting this into \(\LaTeX\) it produces the symbol \(x\). Note that all nodes of a graph are wrapped in a <a href="https://www.cppreference.com/w/cpp/memory/shared_ptr.html"><code>std::shared_ptr</code></a>. so all method are called using the <code>-&gt;</code> operator.</p>
<h2><a class="anchor" id="tutorial_constant"></a>
Constant Nodes</h2>
<p>Next we want to define a constant. There are two method to define constants explicitly or implicitly. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#ab8673e7bc26ebc9c1742f99c9f448ad0">graph::variable</a>(1000, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define explicit constant.</span></div>
<div class="line">    <span class="keyword">auto</span> m = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::constant&lt;T&gt;</a> (0.4);</div>
<div class="line"><span class="comment">// Define implicit constant.</span></div>
<div class="line">    <span class="keyword">const</span> T b = 0.6;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacegraph_html_ab8673e7bc26ebc9c1742f99c9f448ad0"><div class="ttname"><a href="namespacegraph.html#ab8673e7bc26ebc9c1742f99c9f448ad0">graph::variable</a></div><div class="ttdeci">shared_leaf&lt; T, SAFE_MATH &gt; variable(const size_t s, const std::string &amp;symbol)</div><div class="ttdoc">Construct a variable.</div><div class="ttdef"><b>Definition</b> node.hpp:1674</div></div>
</div><!-- fragment --><p> An explicit <a class="el" href="classgraph_1_1constant__node.html">graph::constant_node</a> is created for <code>m</code> while an impicit constant was defined for <code>b</code>. Note in the implicit case, the actual node for <code>b</code> is not created until we use it in an expression.</p>
<hr  />
 <h1><a class="anchor" id="tutorial_expression"></a>
Basic Expressions</h1>
<p>Finally lets create our equation of a line \(y=mx+b\) and generate the \(\LaTeX\) expression for it. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#ab8673e7bc26ebc9c1742f99c9f448ad0">graph::variable</a>(1000, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define explicit constant.</span></div>
<div class="line">    <span class="keyword">auto</span> m = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::constant&lt;T&gt;</a> (0.4);</div>
<div class="line"><span class="comment">// Define implicit constant.</span></div>
<div class="line">    <span class="keyword">const</span> T b = 0.6;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Equation of a line</span></div>
<div class="line">    <span class="keyword">auto</span> y = m*x + b;</div>
<div class="line">    y-&gt;to_latex();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Running this will generate the output <code>\left(0.4 x+0.6\right)</code> which renders to \(\left(0.4 x+0.6\right)\).</p>
<h2><a class="anchor" id="tutorial_derivatives"></a>
Auto Differentiation</h2>
<p>Derivatives of nodes can be taken with respect to any explicit node or graph. As an example lets take the \(\frac{\partial y}{\partial x}\) and render the expression to latex. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#ab8673e7bc26ebc9c1742f99c9f448ad0">graph::variable</a>(1000, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define explicit constant.</span></div>
<div class="line">    <span class="keyword">auto</span> m = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::constant&lt;T&gt;</a> (0.4);</div>
<div class="line"><span class="comment">// Define implicit constant.</span></div>
<div class="line">    <span class="keyword">const</span> T b = 0.6;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Equation of a line</span></div>
<div class="line">    <span class="keyword">auto</span> y = m*x + b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Auto differentiation.</span></div>
<div class="line">    <span class="keyword">auto</span> dydx = y-&gt;df(x);</div>
<div class="line">    dydx-&gt;to_latex();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here we take derivatives using the <a class="el" href="classgraph_1_1leaf__node.html#a4785ca42cddfcfd126bba0bc78a62cab">graph::leaf_node::df</a> method. We can also take several variations of this. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> dydm = y-&gt;df(m);</div>
<div class="line"><span class="keyword">auto</span> dydb = y-&gt;df(b)</div>
<div class="line"><span class="keyword">auto</span> dydy = y-&gt;df(y);</div>
<div class="line"><span class="keyword">auto</span> dydb = y-&gt;df(m*x);</div>
</div><!-- fragment --><p> The results will be \(0.4\), \(x\), \(1\), \(1\), and \(1\) respectively.</p>
<hr  />
 <h1><a class="anchor" id="tutorial_workflow"></a>
Making workflows.</h1>
<p>In this section we will build a workflow from these nodes we created. For simplicity we will decrease the number of elements in the variable so we can set the values easier. First thing we do is create a <a class="el" href="classworkflow_1_1manager.html">workflow::manager</a>. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#ab8673e7bc26ebc9c1742f99c9f448ad0">graph::variable</a>(3, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define explicit constant.</span></div>
<div class="line">    <span class="keyword">auto</span> m = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::constant&lt;T&gt;</a> (0.4);</div>
<div class="line"><span class="comment">// Define implicit constant.</span></div>
<div class="line">    <span class="keyword">const</span> T b = 0.6;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Equation of a line</span></div>
<div class="line">    <span class="keyword">auto</span> y = m*x + b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Auto differentiation.</span></div>
<div class="line">    <span class="keyword">auto</span> dydx = y-&gt;df(x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a workflow manager.</span></div>
<div class="line">    <a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">}</div>
<div class="ttc" id="aclassworkflow_1_1manager_html"><div class="ttname"><a href="classworkflow_1_1manager.html">workflow::manager</a></div><div class="ttdoc">Class representing a workflow manager.</div><div class="ttdef"><b>Definition</b> workflow.hpp:171</div></div>
</div><!-- fragment --><p> This creates a workflow for device 0.</p>
<p>To create a kernal, we add a <a class="el" href="classworkflow_1_1work__item.html">workflow::work_item</a> using the <a class="el" href="classworkflow_1_1manager.html#a8c6bd2f70c3740751fc22ffcfc596e77">workflow::manager::add_item</a> method. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {</div>
<div class="line">    y, dydx</div>
<div class="line">}, {}, NULL, <span class="stringliteral">&quot;my_first_kernel&quot;</span>, 3);</div>
<div class="ttc" id="anamespacegraph_html_a9321a15c96554d065da2ffe49e969ff4"><div class="ttname"><a href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a></div><div class="ttdeci">shared_variable&lt; T, SAFE_MATH &gt; variable_cast(shared_leaf&lt; T, SAFE_MATH &gt; x)</div><div class="ttdoc">Cast to a variable node.</div><div class="ttdef"><b>Definition</b> node.hpp:1746</div></div>
</div><!-- fragment --><p> Here we have created a kernel which computes the outputs of \(y\) and \(\frac{\partial y}{\partial x}\). The third and forth arguments are blank because there are no maps and we are not using random numbers. The last argument needs to match the dimensions of the inputs. Inputs need to be cast from generic <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> to the specific <a class="el" href="classgraph_1_1variable__node.html">graph::variable_node</a>.</p>
<p>To evaluate the kernel, we need to first compile it. Then set the values for \(x\) and run the kernel. To see the results we can print the values of the nodes used. </p><div class="fragment"><div class="line">x-&gt;set({1.0, 2.0, 3.0});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {</div>
<div class="line">    y, dydx</div>
<div class="line">}, {}, NULL, <span class="stringliteral">&quot;my_first_kernel&quot;</span>, 3);</div>
<div class="line">work.compile();</div>
<div class="line"> </div>
<div class="line">work.run();</div>
<div class="line">work.print(0, {x, y, dydx});</div>
<div class="line">work.print(1, {x, y, dydx});</div>
<div class="line">work.print(2, {x, y, dydx});</div>
</div><!-- fragment --><p> Running this we get the output </p><div class="fragment"><div class="line">1 1 0.4</div>
<div class="line">2 1.4 0.4</div>
<div class="line">3 1.8 0.4</div>
</div><!-- fragment --><p>At this point it's important to understand some things that need to be taken into account when working with devices. Note that we needed to set the value of \(x\) before we create the kernel since that's when the device buffers are populated. If we move that to after the kernel is generated. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {</div>
<div class="line">    y, dydx</div>
<div class="line">}, {}, NULL, <span class="stringliteral">&quot;my_first_kernel&quot;</span>, 3);</div>
<div class="line">work.compile();</div>
<div class="line"> </div>
<div class="line">x-&gt;set({1.0, 2.0, 3.0});</div>
<div class="line"> </div>
<div class="line">work.run();</div>
<div class="line">work.print(0, {x, y, dydx});</div>
<div class="line">work.print(1, {x, y, dydx});</div>
<div class="line">work.print(2, {x, y, dydx});</div>
</div><!-- fragment --><p> We get the output </p><div class="fragment"><div class="line">0 0.6 0.4</div>
<div class="line">0 0.6 0.4</div>
<div class="line">0 0.6 0.4</div>
</div><!-- fragment --><p> showing that the device dose not have the updated values. To set values from the host. You need to explicity copy from a host buffer to a device buffer using the <a class="el" href="classworkflow_1_1manager.html#ab04754fe10164787d6dafb77b3051bee">workflow::manager::copy_to_device</a> method. </p><div class="fragment"><div class="line">work.copy_to_device(x, std::array&lt;T, 3&gt; ({1.0, 2.0, 3.0}).data());</div>
<div class="line"> </div>
<div class="line">work.run();</div>
<div class="line">work.print(0, {x, y, dydx});</div>
<div class="line">work.print(1, {x, y, dydx});</div>
<div class="line">work.print(2, {x, y, dydx});</div>
</div><!-- fragment --><p> This restores the expected result. </p><div class="fragment"><div class="line">1 1 0.4</div>
<div class="line">2 1.4 0.4</div>
<div class="line">3 1.8 0.4</div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial_workflow_iter"></a>
Iteration</h2>
<p>In this section we are going to make use of maps to iterate a variable. We want to evaluate the value of \(y\) and set it as the new value of \(x\). We do this my modifying call to <a class="el" href="classworkflow_1_1manager.html#a8c6bd2f70c3740751fc22ffcfc596e77">workflow::manager::add_item</a> to define a map. This generates a kernel where after \(y\) is computed it is stored in the \(x\) buffer. </p><div class="fragment"><div class="line">x-&gt;set({1.0, 2.0, 3.0});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {}, {</div>
<div class="line">    {y, <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)}</div>
<div class="line">}, NULL, <span class="stringliteral">&quot;iteration_kernel&quot;</span>, 3);</div>
<div class="line">work.compile();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; <a class="code hl_variable" href="namespacegraph.html#a9b84f5a5f048fe7931dc4f9d39f5efa6">i</a> &lt; 10; <a class="code hl_variable" href="namespacegraph.html#a9b84f5a5f048fe7931dc4f9d39f5efa6">i</a>++) {</div>
<div class="line">    work.run();</div>
<div class="line">    work.print(1, {x});</div>
<div class="line">}</div>
<div class="ttc" id="anamespacegraph_html_a9b84f5a5f048fe7931dc4f9d39f5efa6"><div class="ttname"><a href="namespacegraph.html#a9b84f5a5f048fe7931dc4f9d39f5efa6">graph::i</a></div><div class="ttdeci">constexpr T i</div><div class="ttdoc">Convinece type for imaginary constant.</div><div class="ttdef"><b>Definition</b> node.hpp:1026</div></div>
</div><!-- fragment --><p> Running this code shows the value of x continously updating. </p><div class="fragment"><div class="line">1.4</div>
<div class="line">1.16</div>
<div class="line">1.064</div>
<div class="line">1.0256</div>
<div class="line">1.01024</div>
<div class="line">1.0041</div>
<div class="line">1.00164</div>
<div class="line">1.00066</div>
<div class="line">1.00026</div>
<div class="line">1.0001</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="tutorial_workflow_newton"></a>
Newton's Method.</h1>
<p>In this tutorial we are going to show how we can put all these concepts together to implement a Newton's method. Newton's method is defined as </p><p class="formulaDsp">
\begin{equation}x = x - \frac{f\left(x\right)}{\frac{\partial}{\partial x}f\left(x\right)}\end{equation}
</p>
<p> From the iteration example, its step update can be handled by a simple map. However, we need a measure for convergence. To do that we output the value of \(f\left(x\right)\). Lets setup a test function. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;jit::<span class="keywordtype">float</span>_scalar T&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_tutorial() {</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::variable&lt;T&gt;</a> (3, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">    x-&gt;set({1.0, 2.0, 3.0});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define an objective function.</span></div>
<div class="line">    <span class="keyword">auto</span> f = 0.2*x*x*x + 0.6*x*x + 0.4*x + 0.5;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Define a step update.</span></div>
<div class="line">    <span class="keyword">auto</span> x_new = x - f/f-&gt;df(x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a workflow manager.</span></div>
<div class="line">    <a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">    work.add_item({</div>
<div class="line">        <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">    }, {f}, {</div>
<div class="line">        {x_new, <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)}</div>
<div class="line">    }, NULL, <span class="stringliteral">&quot;newton_kernel&quot;</span>, 3);</div>
<div class="line">    work.compile();</div>
<div class="line"> </div>
<div class="line">    std::array&lt;T, 3&gt; result;</div>
<div class="line">    T max;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        work.run();</div>
<div class="line">        work.copy_to_host(f, result.data());</div>
<div class="line">        max = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (T &amp;r : result) {</div>
<div class="line">            max = std::max(max, r*r);</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; max &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">while</span> (max &gt; 1.0E-10);</div>
<div class="line">    work.print(0, {x});</div>
<div class="line">    work.print(1, {x});</div>
<div class="line">    work.print(2, {x});</div>
<div class="line">}</div>
</div><!-- fragment --><p> Running shows the objective function and all three elements found the same root. </p><div class="fragment"><div class="line">156.25</div>
<div class="line">14.2408</div>
<div class="line">1.47246</div>
<div class="line">...</div>
<div class="line">5.30397e-06</div>
<div class="line">8.50397e-12</div>
<div class="line">3.03979e-15</div>
<div class="line">-2.6006</div>
<div class="line">-2.6006</div>
<div class="line">-2.6006</div>
</div><!-- fragment --><p>However there are some things that are not optimial here. We are performing a reduction on the host side and transfering the entire array to the host. To improve this we can use a converge item instead. </p><div class="fragment"><div class="line"><span class="comment">// Create a workflow manager.</span></div>
<div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_converge_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {f*f}, {</div>
<div class="line">    {x_new, <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)}</div>
<div class="line">}, NULL, <span class="stringliteral">&quot;newton_kernel&quot;</span>, 3, 1.0E-14);</div>
<div class="line">work.compile();</div>
<div class="line"> </div>
<div class="line">work.run();</div>
<div class="line">work.print(0, {x});</div>
<div class="line">work.print(1, {x});</div>
<div class="line">work.print(2, {x});</div>
<div class="line">}</div>
</div><!-- fragment --><p> We can achieve the same result in a single run call. The advantage here is the reduction is now performed on the device and only a scalar is copied to the host to test for convergence. </p><div class="fragment"><div class="line">-2.6006</div>
<div class="line">-2.6006</div>
<div class="line">-2.6006</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
