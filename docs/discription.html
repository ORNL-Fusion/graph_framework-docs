<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graph Framework: Discription</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Graph Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('discription.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Discription</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#discription_introduction">Introduction</a><ul><li class="level2"><a href="#discription_graphs">Graphs</a><ul><li class="level3"><a href="#discription_graphs_builds">Building Graphs</a></li>
</ul>
</li>
<li class="level2"><a href="#discription_workflows">discription_workflows</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>A discription of the basic functions of the graph_framework.</p>
<h1><a class="anchor" id="discription_introduction"></a>
Introduction</h1>
<p>The basic functionality of this framework is to build expression graphs representing mathematical equations. Reduce those graphs to simpler forms. Transform those graphs to take derivatives. Just-In-Time (JIT) compile them to available compute device kernels. Then run those kernels in workflows. The code is written in using C++23 features. To simplify embedding into legacy codes, there are additional language bindings for C and Fortran.</p>
<h2><a class="anchor" id="discription_graphs"></a>
Graphs</h2>
<div class="image">
<img src="Tree.png" alt=""/>
<div class="caption">
Mathematical operations are defined as a tree of operations. A df method transforms the tree by applying the derivative chain rule to each node. A reduce method applies algebraic rules removing nodes from the graph.</div></div>
<p> The foundation of this framework is build around a tree data structure that enables the symbolic evaluation of mathematical expressions. The <a class="el" href="namespacegraph.html">graph</a> namespace contains classes which symbolically represent mathematical operations and symbols. Each node of the graph is defined as a class derived from a <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> base class. The <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> class defines method to <a class="el" href="classgraph_1_1leaf__node.html#a9dffad49122136d0353d709e0906e8b4">graph::leaf_node::evaluate</a>, <a class="el" href="classgraph_1_1leaf__node.html#adc40a5a5597f45f962cf297e3f4afec7">graph::leaf_node::reduce</a>, <a class="el" href="classgraph_1_1leaf__node.html#a4785ca42cddfcfd126bba0bc78a62cab">graph::leaf_node::df</a>, <a class="el" href="classgraph_1_1leaf__node.html#a24ee329d565a0ad0396374a1b7c784b4">graph::leaf_node::compile</a>, and methods for introspection. A feature unique to this framework is the expression trees can be rendered to \(\LaTeX\) allowing a domain physicist to understand the results of reductions and transformations. This can also be used to identify future reduction opportunities.</p>
<p>An important distinction of this framework compared to other auto differentiation frameworks is there is no distinction between nodes representing operations and nodes representing values. Sub-classes of <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a> include nodes for constants, variables, arithmetic, basic math functions, and trigonometry functions. Other nodes encapsulate more complex expressions like piecewise constants which depend on the evaluation of an argument. These piecewise constants are used implement spline interpolation expressions.</p>
<p>Each node is constructed via factory methods. For common arithmetic operations, the framework overloads the +-*\/ operators to construct expression nodes. The factory method checks a node_cache to avoid building duplicate sub-graphs. Identification of duplicate graphs is performed by computing a hash of the sub-graph. This hash can be rapidly checked if the same hash already exists in a <code>std::map</code> container. If the sub-graph already exists, the existing graph is returned otherwise a new sub-graph is registered in the node_cache.</p>
<p>Each time an expression is built, the reduce method is called to simplify the graph. For instance, a graph consisting of constant added to a constant will be reduced to a single constant by calling the evaluate method. Sub-graph expressions are combined, factored out, or moved to enable better reductions on subsequent passes. As new ways of reducing the graph are implemented, current and existing code built using this framework will benefit from improved speed. The figure above shows a visualization of the tree data structure for the equation of a line, the derivative, and the subsequent reductions.</p>
<h3><a class="anchor" id="discription_graphs_builds"></a>
Building Graphs</h3>
<p>As an example building an expression of line \(y=mx+b\) accomplished by creating a <a class="el" href="classgraph_1_1variable__node.html">graph::variable_node</a> then applying operations on that node. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = <a class="code hl_function" href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::variable&lt;float&gt;</a> (10, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> y = 0.5*x + 0.1;</div>
<div class="ttc" id="anamespacegraph_html_a2b36a8e136f4187b4de7e2e31a3e4168"><div class="ttname"><a href="namespacegraph.html#a2b36a8e136f4187b4de7e2e31a3e4168">graph::zero</a></div><div class="ttdeci">constexpr shared_leaf&lt; T, SAFE_MATH &gt; zero()</div><div class="ttdoc">Forward declare for zero.</div><div class="ttdef"><b>Definition</b> node.hpp:995</div></div>
</div><!-- fragment --><p> In this example, we have created a <a class="el" href="classgraph_1_1variable__node.html">graph::variable_node</a> with the symbol \(x\) containing 10 elements. Then built the expression tree for \(y\). Derivatives are taken using the <a class="el" href="classgraph_1_1leaf__node.html#a4785ca42cddfcfd126bba0bc78a62cab">graph::leaf_node::df</a> method. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> dydx = y-&gt;df(x);</div>
</div><!-- fragment --><p> Reductions are performed transparently as expressions are created so the expression for \(\frac{\partial y}{\partial x}=0.5\). As noted before, since this framework makes no distinction between the various parts of a graph, derivatives and also be taken with respect to sub-expressions. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> dydmx = y-&gt;df(0.5*x);</div>
</div><!-- fragment --><p> In this case, the result will be \(\frac{\partial y}{\partial 0.5*x}=1.0\)</p>
<h2><a class="anchor" id="discription_workflows"></a>
discription_workflows</h2>
<p>A <a class="el" href="classworkflow_1_1manager.html">workflow::manager</a> is responsible for compiling device kernels, and running them in order. One <a class="el" href="classworkflow_1_1manager.html">workflow::manager</a> is created for each device or thread. The user is responsible for creating threads. Each kernel is generated through a <a class="el" href="classworkflow_1_1work__item.html">workflow::work_item</a>. A work item is defined by kernel <a class="el" href="namespacegraph.html#a7f4f9ab246d37d23e0259709e626bc36">graph::input_nodes</a>, <a class="el" href="namespacegraph.html#aec6ce7b08d650c6b236b68bd68a2ce0a">graph::output_nodes</a>, and <a class="el" href="namespacegraph.html#acd48d32bd7925b056e932559379d9b55">graph::map_nodes</a>. Map items are used to take the results of a kernel and update an input buffer. Using our example of line equation, we can create a workflow to compute \(y\) and \(\frac{\partial y}{\partial x}\). </p><div class="fragment"><div class="line"><a class="code hl_class" href="classworkflow_1_1manager.html">workflow::manager&lt;T&gt;</a> work(0);</div>
<div class="line">work.add_item({</div>
<div class="line">    <a class="code hl_function" href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a>(x)</div>
<div class="line">}, {</div>
<div class="line">    y,</div>
<div class="line">    dydx</div>
<div class="line">}, {}, NULL, <span class="stringliteral">&quot;example_kernel&quot;</span>, 10);</div>
<div class="ttc" id="aclassworkflow_1_1manager_html"><div class="ttname"><a href="classworkflow_1_1manager.html">workflow::manager</a></div><div class="ttdoc">Class representing a workflow manager.</div><div class="ttdef"><b>Definition</b> workflow.hpp:171</div></div>
<div class="ttc" id="anamespacegraph_html_a9321a15c96554d065da2ffe49e969ff4"><div class="ttname"><a href="namespacegraph.html#a9321a15c96554d065da2ffe49e969ff4">graph::variable_cast</a></div><div class="ttdeci">shared_variable&lt; T, SAFE_MATH &gt; variable_cast(shared_leaf&lt; T, SAFE_MATH &gt; x)</div><div class="ttdoc">Cast to a variable node.</div><div class="ttdef"><b>Definition</b> node.hpp:1747</div></div>
</div><!-- fragment --><p> Here we have defined a kernel called "example_kernel". It has one input \(x\), two outputs \(y\) and \(\frac{\partial y}{\partial x}\), and no maps. The <code>NULL</code> argument signifies there is no <a class="el" href="namespacegraph.html#ae2084dfa9523b7c8cab9a9912f65a974">graph::random_state</a> used. The last argument needs to match the number of elements in the inputs. Multiple work items can be created and will be executed in order of creation.</p>
<p>Once the work items are defined they can be JIT compiled to a backend device. The graph framework supports back ends for generic CPUs, Apple Metal GPUs, Nvidia Cuda GPUs, and initial HIP support of AMD GPUs. Each back end supplies relevant driver code to build the kernel source, compile the kernel, build device data buffers, and handle data synchronization between the device and host. All JIT operations are hidden behind a generic <a class="el" href="classjit_1_1context.html">jit::context</a> interface.</p>
<p>Each context, creates a specific kernel preamble and post-fix to build the correct syntax. Memory access is controlled by loading memory once in the beginning, and storing the results once at the end. Kernel source code is built by recursively traversing the output nodes and calling the <a class="el" href="classgraph_1_1leaf__node.html#a24ee329d565a0ad0396374a1b7c784b4">graph::leaf_node::compile</a> method of each <a class="el" href="classgraph_1_1leaf__node.html">graph::leaf_node</a>. Each line of code is stored in a unique register variable assuming infinite registers. Duplicate code is eliminated by checking if a sub-graph has already been traversed. Once the kernel source code is built, the kernel library is compiled, and a kernel dispatch function is created using a C++ lambda function. The resulting workflow can be called multiple times. </p><div class="fragment"><div class="line">work.compile();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 100; i++) {</div>
<div class="line">    work.run();</div>
<div class="line">}</div>
<div class="line">work.wait();</div>
</div><!-- fragment --><p> While this API is more explicit compared to the capabilities of JAX, PyTorch, TensorFlow, and MLX, it doesn't result in unexpected situations where graphs are being rebuilt and the user can trust when evaluation is finished. Additionally device buffers are only created for kernel inputs and outputs allowing the user to explicitly control memory usage. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
